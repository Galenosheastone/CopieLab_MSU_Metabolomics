---
title: "PLSDA_Main_v5.9_MixOmics_build"
author: "Galen O'Shea-Stone"
date: "8/19/2021"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

https://mixomicsteam.github.io/Bookdown/plsda.html

```{r}
library(MetaboAnalystR)
library(tidyverse)
library(rpca)
#library(caret)
library(DiscriMiner)
library(ggthemes)
library(mixOmics)
library(ggrepel)
library(gt)
library(plotly)
#initalizes all the libraries needed 
```

library(doParallel) 
rCluster <- makePSOCKcluster(6)
registerDoParallel(rCluster)
#initates parallel processing 

```{r, echo = FALSE, include=FALSE}
## This chunk reads in raw .csv performs scaling, normalization and log transform then outputs all the data back into the working directory
{mSet <- InitDataObjects("conc", "stat", paired = FALSE)
mSet <- Read.TextData(mSet, "EXAMPLE_DATA_GOOD_SEP.csv", "rowu", "disc")
###INSERT YOUR DATA FILE NAME HERE###
#change from rowu to colu for column data vs row  
#rowp vs colp for paired analysis 

#Perform data processing
mSet <- SanityCheckData(mSet)
mSet <- ReplaceMin(mSet);
mSet <- PreparePrenormData(mSet)
mSet <- Normalization(mSet, "SumNorm", "LogNorm", "AutoNorm", ref= NULL, ratio = FALSE, ratioNum = 20)
#change your parameters above
#especially important to change SumNorm --> none if pre-normalized to protein/ cell number etc. 
mSet <- PlotNormSummary(mSet, "norm_O_", "png",72, width = NA)
mSet <- PlotSampleNormSummary(mSet, "snorm_O_", "png",72, width = NA)
mSet <-SaveTransformedData(mSet)
}

#after this is done, there will be  new files in the working directory 
#important one moving forward is titled data_normalized.csv

```

```{r}

m.data.all <- read.csv("data_normalized.csv")

###This chunk does all the analysis of the PLSDA model, the PCA analysis and Random forest###

m.data.all <- read.csv("data_normalized.csv")
m.data.all <- m.data.all[-c(1)]
#reads in all data and gets rid of the X comumn (sample ID)

m.data.groups <- read.csv("data_normalized.csv")
m.data.groups <- as.data.frame(m.data.groups$Label)
#creates a specific column which is just the treatment group

names(m.data.groups)[names(m.data.groups) == "m.data.groups$Label"] <- "Label"
#changes column name to Label (just to tidy up)


m.data.groups$Label <- m.data.groups$Label %>% recode(`0`= "VARIABLE_A_HERE", `1`="VARIABLE_B_HERE")
#changes 0 and 1 (separation between paired treatments to whatever is above)...this is for the paired analysis
###MAKE SURE TO CHANGE VARIABLE NAMES HERE###

m.data.groups <- as.factor(m.data.groups$Label)
#creates group data as factor with only groups w/ treatment type

{m.data <- read.csv("data_normalized.csv")
m.data <- as.data.frame(m.data)
m.data <- m.data[-c(1:2)]
}

X <- as.matrix(m.data)
#creates matrix of the data without labels
#creates vector with only numerical matrix
X <- X * -1
#still needed to match metaboanalyst as of 10/14/20
Y <- as.factor(m.data.groups)  
#creates factor vector with group separation

set.seed(0666)
#for reproducibility

## PLS-DA function
plsda.res <- plsda(X, Y, ncomp = 5, mode = "classic", max.iter = 100)
# where ncomp is the number of components wanted
#computes PLS-DA model using MixOmics package 
#mode = What type of algorithm to use, (partially) matching one of "regression", "canonical", "invariant" or "classic". See Details.
#If mode = "X" becomes an issue this is due to the version of mixOmics works with v6.17.26 so either install this version from bioconductor or delete mode = "x" option


# this code takes ~ 1 min to run or sometimes longer depending on your processor speed 

cim(plsda.res, comp=1, title ="Component 1", save = "pdf", name.save = "cim_PLSDA", transpose = TRUE)


set.seed(0666) 
# for reproducibility here, only when the `cpus' argument is not used
perf.plsda <- perf(plsda.res, validation = c("Mfold"), folds = 5, 
                   #can also use "loo" validation
                  progressBar = TRUE, auc = TRUE, nrepeat = 10) 
# perf.plsda.srbct$error.rate  # error rates
perf.plsda
plot(perf.plsda, col = color.mixo(1:3), sd = TRUE, legend.position = "horizontal") 

PLSDA.plot <- plotIndiv(plsda.res, ind.names = FALSE, legend=TRUE,
          ellipse = TRUE, star = FALSE, title = "PLSDA CHECK",
          )

auc.plsda <- auroc(plsda.res)
#plots the ROC curve, this is used later to save it to the working directory

AUROC.fig <- auc.plsda$graph.Comp1
#creates data for AUROC fig
AUROC.fig <- AUROC.fig + theme(legend.position="bottom")
#changes the position of the legend 
AUROC.fig

ggsave("AUROC_HERE.pdf", plot = AUROC.fig, units="in", width= 8, height=10, dpi=1000)
#saves AUROC pdf to working dir 


contrib.metabs <- plotLoadings(plsda.res, comp = 1, contrib = 'max', method = 'median', 
                               legend.title = "Capture", ndisplay = 100, size.legend = 1, 
                               title = "Importance to Component 1", size.title = 1.0
                                )
#change the desired component here i.e. comp = 1, 2 ,3 etc

#This function provides a horizontal bar plot to vizualise loading vectors. For discriminant analysis, it provides vizualisation of highest or lowest mean/median value of the variables with color code corresponding to the outcome of interest.


###FOR 3D PLSDA SEE BELOW!!!!####
#plotIndiv(plsda.res, style="3d")
#use this to create a 3D PLSDA

spls.res <- splsda(X, Y, ncomp = 5, mode = "classic", max.iter = 100)


val <- perf(spls.res, criterion = c("all"), folds = 5)
val
plot(val)
#this is all for running SPLSDA 


```

```{r}
#this is for validation metrics and VIP scores tables 

Y.mat <- unmap(Y)
res <- pls(X, Y.mat)
val <- perf(res, validation = "Mfold", criterion = c("R2", "Q2"))
val

plot(val$R2)
val$Q2
val$R2
val$Q2.total
##VALIDATION METRICS --OTHER these will out put Q2, R2 and total Q2 walues 



#BELOW ARE ALL PLSDA METRICS
plsda.metrics <- perf(plsda.res,
          dist = c("all", "max.dist", "centroids.dist", "mahalanobis.dist"),
          validation = c("Mfold", "loo"),
          folds = 10, nrepeat =1, auc = TRUE, progressBar = TRUE)

plsda.metrics$error.rate.all
#use this to find wherer the BER (balanced error rate and the max distance are the lowest )

plsda.metrics$auc.all
plsda.metrics$auc
#gives you area under the curve values (AUC) for the models clkassification ability


#use this to find wherer the BER (balanced error rate and the max distance are the lowest )
```




```{r}

set.seed(0666) # for reproducbility in this vignette, otherwise increase nrepeat
MyPerf.plsda <- perf(plsda.res, validation = "Mfold", folds = 5, 
                  progressBar = TRUE, nrepeat = 10, criterion = c("R2", "Q2")) 
# we suggest nrepeat = 50...changed to 10 to reduce computational time
#can chamnge validation to "loo" if needed (leave one out)

metrics.PLSDA <- plot(MyPerf.plsda, col = color.mixo(5:7), sd = TRUE, legend.position = "vertical")

plsda.test <- plsda.res$variates

plsda.data <- (plsda.test$X)
#pulls the scores data from the plsda model 

plsda.data <- as.data.frame(plsda.data)
#changes into dataframe for ggplot 

m.data.groups <- as.data.frame(m.data.groups)
#changes groups back into dataframe instead of matrix 

new.plsda.data <- cbind(plsda.data, m.data.groups)
#combines the groups with the plsda components data 

names(new.plsda.data)[names(new.plsda.data) == "m.data.groups"] <- "Group"
#changes column name to Label (just to tidy up)

comp.var <- as.data.frame(plsda.res$explained_variance$X)
#pulls out the explained variances for the selected components 
comp.var <- as.data.frame(t(comp.var))
#transposes the dataframe for referencing 

comp1.var <- comp.var$`comp 1`
comp2.var <-comp.var$`comp 2`
comp3.var <- comp.var$`comp 3`

##BELOW WILL BE THE VARIENCES FOR COMP 1 & 2##
comp1.var
#component 1 variance 
comp2.var
#component 2 variance 
comp1.var <- comp1.var *100
comp2.var <- comp2.var *100
comp3.var <- comp3.var *100

#multiplies both by 100 for %
comp1.var <- signif(comp1.var, 3)
comp2.var <- signif(comp2.var, 3)
comp3.var <- signif(comp3.var, 3)

print("Above are the variences for component 1 (top) and component 2 (bottom)")
#see the end of chunk

plsda.plot <- ggplot(new.plsda.data, aes(x= comp1, y= comp2, color = Group)) +
              geom_jitter(size = 0.5, shape = 1, fill = "black", stroke = 0.5, aes(color = Group)) + 
              theme_bw() +
              #changes the theme of the plot 
              ggtitle("YOUR_TITLE_HERE") +
              ###MAKE SURE TO INSERT TITLE HERE
              xlab(paste("Component 1:", comp1.var, "%"))+
              ylab(paste("Component 2:", comp2.var, "%")) +
              #inserts variance for specific components  
              scale_color_manual(name="Variety", values=c("darkorchid2","darkorange", "springgreen2", "cyan")) +
              #changes the color nanually and easier than below using scale_color_hue
              stat_ellipse(type = "t", geom = "polygon", alpha = 1/4, aes(fill = Group), show.legend = FALSE) + 
              scale_fill_manual(values=c("darkorchid2","darkorange", "springgreen2", "cyan")) 
              #geom_text(label = m.data)
#you will need to  add the amount of variance for each sample manually...get this from MA code? --> ...work in progress
#plsda.plot

#you will need to  add the amount of variance for each sample manually...get this from MA code? --> ...work in progress
#plsda.plot
  
plsda.plot <- plsda.plot + stat_ellipse(type = "t") 
#sets the confidence interval type (norm = 95%) --> this can be customized(see below)
#The default "t" assumes a multivariate t-distribution, and "norm" assumes a multivariate normal distribution. "euclid" draws a circle with the radius equal to level, representing the euclidean distance from the center. This ellipse probably won't appear circular unless coord_fixed() is applied.
#plsda.plot <- plsda.plot + scale_color_brewer(palette="dark2")
#uses scale color brewer to set colors

#plsda.plot <- plsda.plot + scale_color_hue(l=70, c=90)
#The lightness (l) and the chroma (c, intensity of color) of the default 
#(hue) colors can be modified using the functions scale_hue 


###OR###

#insert this for color
#scale_color_manual(name="Variety", values=c("springgreen2", "firebrick2")) 
#change colors manually using R names 
  
#Insert code to change the title here if needed 

plsda.plot <- plsda.plot + theme(plot.title = element_text( face = "bold", color = "black", size = NA))


#below is options for the legend of the PLSDA plot
plsda.plot <- plsda.plot +
  theme(legend.position="right") +
              theme(legend.title = element_text(colour="Black", size=10, face="plain")) +
              theme(legend.text = element_text(colour="black", size=10, face="plain")) +
              #theme(legend.background = element_rect(fill="lightblue", size=0.5, linetype="solid", colour ="darkblue")) +
              #creates box around legend 
              theme(legend.title = element_blank()) +
              #removes plot legend title
              theme(legend.position='bottom') 
              #removes entire legend or changes the location of legend ("left", "right", "bottom" etc... )
              #scale_x_reverse()
              #this is needed to flip x axis to match metaboanalyst as of 10/14/20 ...sometimes...
              #double check that this is needed and turn off or on as needed


plsda.plot <- plsda.plot + scale_x_reverse()
#needed to match metaboanalyst x axis as of 3/17/21... turn off to flip back if needed

plsda.plot <- plsda.plot + scale_y_reverse()
#put in to match MA code 8/19/21



plsda.plot
#shows the plot for pre-editing


#Saves ROC and PLSDA to working directory 

{png(filename = "PLSDA_ROC_Plot_here.png",
    width = 500, height = 500, units = "px", pointsize = 12,
     bg = "white",  res = NA)
auroc(plsda.res)
dev.off()
}
#work on plotting the ROC better in later builds

{png(filename = "PLSDA_CER_PLOT_HERE.png",
    width = 500, height = 500, units = "px", pointsize = 12,
     bg = "white",  res = NA)
plot(MyPerf.plsda, col = color.mixo(5:7), sd = TRUE, legend.position = "vertical")
dev.off()
}

ggsave("High_Quality_PLSDA.pdf", plot = plsda.plot, units="in", width= 6, height=5, dpi=400)
#turn this off if you don't want a pdf version

explained.var <- sum(plsda.res$explained_variance$X)
message("This is the explained varience for X components ", explained.var)
#calculates the amount of varience explained by the number of components selected 


#ggsave("High_Quality_PLSDA.tiff", plot = plsda.plot, units="in", width= 6, height=5, dpi=400, compression = 'lzw')
#creates a high quality file of the PLSDA plot in the working dir 
#use the above code to make journal quality files


########NOTE THAT IF YOUR ROC CURVE SHOWS ROC<.5 DO NOT USE!!!
#IF YOU DO NOT SEE A PLS-DA SCATTERPLOT --> THE MODEL IS NOT PREDICTIVE AND YOU SHOULD NOT USE PLS-DA!!!!################
#this might not be relavent using the MixOmics build

#if you get a null 1, can't shut off device or dev.off() error try restarting R 
# or use the code line below?  
# while (!is.null(dev.list()))  dev.off()

##NOTE that if you're intersested in ROC for specific components see below##

```
Note, PLS-DA maximizes the covariance between X (data) and Y (group). The variance displayed in the plot above is the explained variance for X. Covariance and x-variance may not agree with each other in some cases. For instance, the 1st component may not explain more X-variance than the 2nd component.





#```{r}

plotIndiv(plsda.res, 
          group = Y, 
          #ind.names = ,
          legend =TRUE, 
          ellipse = TRUE, 
          rep.space = 'XY-variate',
          title = '3D-PLSDA',
          star = FALSE, 
          centroid = FALSE,
          style='3d')
library('rgl')
rgl.snapshot('3dplot.png', fmt = 'png')
#to save the exact image in the rgl plot

#```

#use the above code to create a 3D interactive PLSDA plot




```{r}
###This chunk does visualization of the loading plot for the PLSDA model

graph.loadings <- (plsda.res$loadings$X)
#this gets the scores data and creates a matrix with the main Principal components

graph.loadings <-as.data.frame(graph.loadings)


  #you can change this here to fit your grouping variable for the plot
{names(graph.loadings)[1] <- "Loadings1"
#these correspond to components 1,2,3,4 etc...
names(graph.loadings)[2] <- "Loadings2"
names(graph.loadings)[3] <- "Loadings3"
names(graph.loadings)[4] <- "Loadings4"
}

graph.loadings$`Metabolite` <- rownames(graph.loadings)
#pulls out metabolite names

plsda.loadings.plot <- ggplot(graph.loadings, aes(x= Loadings1, y= Loadings2)) +
  #you can change the components represented by changing the x and y above
              geom_jitter(size = 1.0, shape = 21, fill = "blue") + 
              theme_bw() +
              #changes the theme of the plot 
              ggtitle("PLS-DA Loadings Plot") +
              xlab("Loadings 1") +
              ylab("Loadings 2 ") +
              geom_text_repel(aes(x= Loadings1, y=Loadings2, label = Metabolite), size = 3, force = 2)
              #forces the text to repel and options with that
  
plsda.loadings.plot

ggsave("HQ_PLSDA_Loadings.pdf", plot = plsda.loadings.plot, units="in", width= 6, height=5, dpi=400)
#ggsave("HQ_PLSDA_Loadings.tiff", plot = plsda.loadings.plot, units="in", width= 6, height=5, dpi=400, compression = 'lzw')

#below does the VIP scores plotting
vip.scores <- vip(plsda.res)

vip.scores <- as.data.frame(vip.scores)
#vip.significant <- vip.scores[order(vip.scores$comp1), ]
#orders the VIP scores 

vip.significant <- subset(vip.scores, comp1 >= 1.2, select=c(comp1))

#INSERT ggplot 

vip.significant$`Metabolite` <- rownames(vip.significant)

theme_set(theme_bw())

vip.bar <- ggplot(vip.significant, aes(x=Metabolite, y=comp1)) + 
            geom_bar(stat="identity", width=.5, fill="tomato3") + 
              labs(title="Variable Importance in Projection", 
                   subtitle="VIP >1.2", 
                   caption="caption") + 
               ylab("VIP Score") +
               theme(axis.text.x = element_text(angle=65, vjust=0.6))
vip.bar

vip.significant$comp1 <- round(vip.significant$comp1, 3)
#changes the number of digits 


vip.lollipop <- ggplot(vip.significant, aes(x= reorder(Metabolite, -comp1), y=comp1, label=comp1)) + 
                      geom_point(size=6)  +
                      geom_segment(aes(y = 0, 
                                       x = Metabolite, 
                                       yend = comp1, 
                                       xend = Metabolite), 
                                   color = "black") +
                      geom_text(color="white", size=2) +
                       labs(title="YOUR_TITLE_HERE", 
       subtitle="Variable Importance in Projection (VIP) >1.2", 
       caption="") + 
    ylab("VIP Score") +
    xlab(NULL) +
    geom_hline(yintercept = 1.2, color = "red2", linetype = "dashed") +
  theme(axis.text.x = element_text(angle=65, vjust=0.6))

vip.lollipop

ggsave("VIP_LOLLIPOP_HERE.pdf", plot = vip.lollipop, units="in", width= 6, height=5, dpi=1000)
#ggsave("VIP_LOLLIPOP_HERE.tiff", plot = vip.lollipop, units="in", width= 6, height=5, dpi=1000, compression = 'lzw')

```

```{r}

##this chunk will take the data of the importance created in the PLSDA model and visualizes
#provides a horizontal bar plot to visualise loading vectors. For discriminant analysis, it provides visualisation of highest or lowest mean/median value of the variables with color code corresponding to the outcome of interest.

#This set of visualizations  provides a horizontal bar plot to visualise loading vectors. For discriminant analysis, it provides visualisation of highest or lowest mean/median value of the variables with color code corresponding to the outcome of interest.

#The contribution of each variable for each component (depending on the object) is represented in a barplot where each bar length corresponds to the loading weight (importance) of the feature. The loading weight can be positive or negative.

contrib.metabs <- plotLoadings(plsda.res, comp = 1, contrib = 'max', method = 'median', legend.title = "Capture", ndisplay = 100, size.legend = 1, title = "Importance to Component 1", size.title = 1.0)
#change the desired component here#loads the data as a dataframe using plotLoading function from MixOmics


contrib.metabs$`Metabolite` <- rownames(contrib.metabs)
#makes a new row called "Metabolite"
#Pulls the names of metabolites out of the 0 column (there is another name for this column...)
contrib.metabs <- contrib.metabs[order(contrib.metabs$importance), ]
#sorts them
contrib.metabs$Metabolite <- factor(contrib.metabs$Metabolite, levels = contrib.metabs$Metabolite)
# convert to factor to retain sorted order in plot.
contrib.metabs$importance <- round(contrib.metabs$importance, 2)
#this is needed to simplify the amount of decimals for the later plots

theme_set(theme_bw())
contrib.metab.fig <- ggplot(contrib.metabs, aes(x=Metabolite, y=importance, label=NA)) + 
                      geom_bar(stat='identity', aes(fill=GroupContrib), width=.5)  +
                      scale_fill_manual(name="Importance", 
                                        labels = c("VARIABLE_1", "VARIABLE_2", "VARIABLE_3", "VARIABLE_4"), 
                                        #change these manually--from new.plsda.data 
                                        values = c("darkorchid2","darkorange", "springgreen2", "cyan")) + 
                      labs(subtitle="", 
                           title= "LAbel_here") +
                        ylab("Importance") +
                      coord_flip()
#creates diverging bars plot
contrib.metab.fig

contrib.metab.fig2 <- ggplot(contrib.metabs, aes(x= Metabolite, y=importance, label=importance)) + 
                      geom_point(stat='identity', fill="black", size=6)  +
                      geom_segment(aes(y = 0, 
                                       x = Metabolite, 
                                       yend = importance, 
                                       xend = Metabolite), 
                                   color = "black") +
                      geom_text(color="white", size=2) +
                      labs(title="Title_Here", 
                           subtitle="Subtitle_here") + 
                      coord_flip()
#Creates diverging lollipop chart
contrib.metab.fig2



contrib.metab.fig3 <- ggplot(contrib.metabs, aes(x=Metabolite, y=importance, label=importance)) + 
                      geom_point(stat='identity', aes(col=GroupContrib), size=3)  +
                      scale_color_manual(name="", 
                                         labels = c("VARIABLE_1", "VARIABLE_2", "VARIABLE_3", "VARIABLE_4"),
                                         #change these manually 
                                         values = c("darkorchid2","darkorange", "springgreen2", "cyan")) + 
                      #geom_text(color="white", size=2) +
                      labs(title="PLS-DA Metabolite Importance: ComponentX", 
                           #make sure to adjust this above! 
                           subtitle="") + 
                        ylab("Importance") +
                      coord_flip()
#creates diverging dotplot chart
contrib.metab.fig3


ggsave("Importance.pdf", plot = contrib.metab.fig, units="in", width= 8, height=10, dpi=1000)
ggsave("Importance2.pdf", plot = contrib.metab.fig2, units="in", width= 8, height=10, dpi=1000)
ggsave("Importance3.pdf", plot = contrib.metab.fig3, units="in", width= 8, height=10, dpi=1000)
#create .tiff files in the working directory 

#ggsave("Importance.tiff", plot = contrib.metab.fig, units="in", width= 6, height=7, dpi=1000, compression = 'lzw')
#ggsave("Importance2.tiff", plot = contrib.metab.fig2, units="in", width= 6, height=7, dpi=1000, compression = 'lzw')
#ggsave("Importance3.tiff", plot = contrib.metab.fig3, units="in", width= 6, height=8, dpi=1000, compression = 'lzw')
#create .tiff files in the working directory 

```

```{r}
#3D PLSDA DEVELOPMENT CHUNK

PCA.data.3D <- as.factor(new.plsda.data$Group)


comp1.var
comp2.var
comp3.var

PC1.X <- new.plsda.data$PC1
PC2.Y <- new.plsda.data$PC2
PC3.Z <- new.plsda.data$PC3



fig <- plot_ly(new.plsda.data, x = ~comp1, y = ~comp2, z = ~comp3, color = ~Group, colors = c("darkorchid2","darkorange"))
               marker = list(color = ~PC1, colorscale = c('#FFE1A1', '#683531'), showscale = TRUE)
fig <- fig %>% add_markers(marker = list(size = 5,
                             #color = c("darkorchid2","darkorange"),
                             line = list(color = c ("blue4","black"),
                                         width = 1)))
fig <- fig %>% layout(title = "INSERT_TITLE_HERE", plot_bgcolor = "#e5ecf6")
fig <- fig %>% layout(scene = list(xaxis = list(title = "PC 1: INSERT_VAR_HERE%"),
                     yaxis = list(title = "PC 2: INSERT_VAR_HERE%"),
                     zaxis = list(title = "PC 3: INSERT_VAR_HERE%")))
fig




```







```{r}

##This creates a table with the VIP scores for the top 5 components as an excel file 

vip.view <-vip(plsda.res)
vip.view
#pulls out VIP scores in a table for the top 5 components  
vip.table <- as.data.frame(vip.view)
#changes to dataframe
vip.table <- vip.table[with(vip.table,order(-comp1)), ]
#reorganizes as descending values based on comp1 
vip.table
#look at table
write.csv(vip.table,"VIP_table.csv", row.names = TRUE)
# as excel file for export

vip.table <- cbind(Metabolite = rownames(vip.table), vip.table)
#changes row names  to column 1 



###SOMETIMES THE VIP TABLE comp1 =component 1... GETS REVERSED USE ONE OF THE TWO CHANGES TO GET IT TO WORK 

#vip.table <- rename (vip.table, c("comp1" = "Component 1", "comp2" = "Component 2", "comp3" = "Component 3","comp4" = "Component 4","comp5" = "Component 5" ))
#vip.table

vip.table <- rename (vip.table, c("Component 1" = "comp1", "Component 2" = "comp2", "Component 3" = "comp3", "Component 4" = "comp4", "Component 5" = "comp5" ))
vip.table

###

VIP.gt.table <- gt(vip.table)
#creates gt object
VIP.gt.table <- 
  VIP.gt.table %>%
  tab_header(
    title = md("PLS-DA VIP Scores"),
    subtitle = ""
  ) 
#adds title to VIP table
VIP.gt.table

gtsave(VIP.gt.table, "VIP_TABLE_HERE.pdf")
#saves VIP table to working dir 


```
```{r}

#in development

#plsda.biplot <- plsda(X, Y, ncomp = 2)


#biplot(plsda.biplot, cutoff = 0.72)


```




```{r}
#below put metrics graphics in working directory...somewhat outdated as of 11/17/20

{png(filename = "PLSDA_METRICS_here.png",
    width = 500, height = 500, units = "px", pointsize = 12,
     bg = "white",  res = NA)
plot(perf.plsda)
dev.off()
}


{png(filename = "AUC_curve_here.png",
    width = 500, height = 500, units = "px", pointsize = 12,
     bg = "white",  res = NA)
plot(auc.plsda$graph.Comp1)
dev.off()
}


{png(filename = "Contrib.metabolites.png",
    width = 500, height = 500, units = "px", pointsize = 12,
     bg = "white",  res = NA)
plot(contrib.metabs)
dev.off()
}

{png(filename = "Contrib.metabolites.png",
    width = 500, height = 500, units = "px", pointsize = 12,
     bg = "white",  res = NA)
plot(contrib.metabs)
dev.off()
}

{png(filename = "Contrib.metabolites_graph.png",
    width = 500, height = 500, units = "px", pointsize = 12,
     bg = "white",  res = NA)
contrib.metabs
dev.off()
}


{png(filename = "Contrib.metabolites.png",
    width = 500, height = 500, units = "px", pointsize = 12,
     bg = "white",  res = NA)
plot(contrib.metabs)
dev.off()
}

{png(filename = "Tuned_PLSDA_Parameters.png",
    width = 500, height = 500, units = "px", pointsize = 12,
     bg = "white",  res = NA)
plot(MyPerf.plsda)
dev.off()
}

{png(filename = "PLSDA_VARIENCE_HERE.png",
    width = 500, height = 500, units = "px", pointsize = 12,
     bg = "white",  res = NA)
PLSDA.plot
dev.off()
}


```

{png(filename = "AUC_curve_here.png",
    width = 500, height = 500, units = "px", pointsize = 12,
     bg = "white",  res = NA)
plot(auc.plsda$graph.Comp1)
dev.off()
}
#old way to save the AUROC curve without modification 
